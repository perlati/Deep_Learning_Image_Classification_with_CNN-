# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CPYCTxxxvC1k47PJ1QQJ0gkZlliJaq_a
"""

from google.colab import drive
drive.mount('/content/drive')

pip install --upgrade gradio

"""This is a suggestion how we could update the code to upload images that need to be classified with an ml model"""

import os, numpy as np, gradio as gr, tensorflow as tf
from tensorflow import keras
from keras.saving import register_keras_serializable

# --- Custom LR schedule (only needed if present in your saved model) ---
@register_keras_serializable(package="schedules", name="CosineSmall")
class CosineSmall(tf.keras.optimizers.schedules.LearningRateSchedule):
    def __init__(self, steps_per_epoch, total_epochs_ft, base_lr):
        self.steps_per_epoch = steps_per_epoch
        self.total_epochs_ft = total_epochs_ft
        self.base_lr = base_lr
    def __call__(self, step):
        total_steps = tf.cast(self.steps_per_epoch * self.total_epochs_ft, tf.float32)
        x = tf.cast(step, tf.float32) / tf.maximum(total_steps, 1.0)
        return self.base_lr * 0.5 * (1.0 + tf.cos(tf.constant(tf.pi) * x))
    def get_config(self):
        return {
            "steps_per_epoch": self.steps_per_epoch,
            "total_epochs_ft": self.total_epochs_ft,
            "base_lr": self.base_lr,
        }

# --- Register preprocess_input if model was saved with a Lambda layer ---
@register_keras_serializable(package="preproc", name="preprocess_input")
def preprocess_input(x):
    try:
        from tensorflow.keras.applications.mobilenet_v2 import preprocess_input as f
        return f(x)
    except Exception:
        return tf.identity(x)

# --- Load your model safely (no optimizer state needed) ---
MODEL_PATH = os.getenv("/content/model.keras", "model.keras")
model = keras.models.load_model(
    MODEL_PATH,
    custom_objects={"CosineSmall": CosineSmall, "preprocess_input": preprocess_input},
    compile=False,
)

# --- CIFAR-10 labels ---
CLASS_NAMES = ['airplane', 'automobile', 'bird', 'cat', 'deer',
               'dog', 'frog', 'horse', 'ship', 'truck']

# --- Infer model input size ---
in_shape = model.inputs[0].shape
_, H, W, C = in_shape
H, W, C = int(H), int(W), int(C)

def preprocess_pil(img):
    img = img.convert("RGB")
    img = img.resize((W, H))
    arr = np.asarray(img, dtype=np.float32)
    # If you trained on [0,1] values, uncomment:
    # arr = arr / 255.0
    return np.expand_dims(arr, 0)  # (1, H, W, 3)

def predict(image):
    x = preprocess_pil(image)
    y = model(x, training=False).numpy().squeeze()

    # Apply softmax for safety
    ex = np.exp(y - y.max())
    probs = ex / ex.sum()

    return {CLASS_NAMES[i]: float(probs[i]) for i in range(len(CLASS_NAMES))}

demo = gr.Interface(
    fn=predict,
    inputs=gr.Image(type="pil", label="Upload an image"),
    outputs=gr.Label(num_top_classes=3, label="Top predictions"),
    title="CIFAR-10 Image Classifier",
    description=f"Model: {os.path.basename(MODEL_PATH)} â€” predicts one of 10 CIFAR-10 classes.",
)

if __name__ == "__main__":
    demo.launch()